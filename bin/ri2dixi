#!/usr/bin/env ruby
#
#  Copyright 2009 John Croisant
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
#  

# This is a script to read RI documentation generated by RDoc and
# output it as YAML suitable to be posted to Dixi.


require 'optparse'
require 'uri'
require 'pathname'
require 'rdoc/ri/reader'


NAME = "ri2dixi"
VERSION = [0,1]


# Copied from dixi/src/resource.rb, 2010-01-01
TYPE_SUFFIXES = {
  "module"          => "-m",
  "class"           => "-c",
  "module method"   => "-mm",
  "class method"    => "-cm",
  "instance method" => "-im",
}


unless Object.new.respond_to? :tap
  def Object.tap( &block )
    yield self if block_given?
    self
  end
end


def main
  options = handle_options
  options[:input].each{ |dir|  process_dir(dir, options[:output]) }
end


def handle_options
  options = {:input => []}

  OptionParser.new do |opts|
    opts.banner =
      "Usage: #{NAME} -o output_dir -i input_dir [-i input_dir2 ...]"

    opts.separator ""


    opts.on( "-o", "--output DIR", "Directory to save output." ) do |dir|
      dir = Pathname.new(dir)
      begin
        dir.mkpath
        if dir.writable?
          options[:output] = dir
        else
          puts "ERROR: Output directory is not writeable."
          exit 1
        end
      rescue Errno::EACCES => e
        puts "ERROR: Cannot create output directory: #{e}"
        exit 1
      end
    end


    opts.on( "-i", "--input DIR", "RI directory to scan. Give this flag",
             "more than once to scan multiple dirs.") do |dir|
      dir = Pathname.new(dir)
      if dir.directory? and dir.readable?
        options[:input] << dir
      else
        puts "Ignoring invalid/missing input directory: #{dir}"
      end
    end


    opts.separator ""

    opts.on_tail( "-h", "--help", "Print this help information." ) do
      puts opts
      exit 0
    end

    opts.on_tail( "-v", "--version", "Print #{NAME}'s version number." ) do
      puts "#{NAME} v#{VERSION.join(".")}"
      exit 0
    end

  end.parse!

  if options[:output].nil?
    puts "ERROR: No output directory specified. Aborting."
    exit 1
  end

  if options[:input].empty?
    puts "ERROR: No input directories specified. Aborting."
    exit 1
  end

  options
end


def process_dir( input_dir, output_dir )
  require 'find'
  Find.find( input_dir.to_s ) do |path|
    if path =~ /\.yaml$/
      path = Pathname.new(path)
      begin
        print "#{path.relative_path_from(input_dir)}  -->  "
        process_file( path, output_dir )
      rescue => e
        puts "Error:\n  #{e}"
      end
    end
  end
end


def process_file( input_file, output_dir )
  data = RIDumper.dump_ri( YAML.load_file( input_file ) )

  parts = data["name"].split(/::|#|\./)
  parts[-1] += TYPE_SUFFIXES[data["type"]] || ""
  parts[-1] += ".yaml"
  output_file = output_dir.join( *parts )
  puts output_file

  output_file.parent.mkpath
  output_file.open("w") { |f|
    f << data.to_yaml
  }
end



module RIDumper

  class UnknownRIObject < RuntimeError; end
  class UnknownMarkup < RuntimeError; end

  class << self

    # Dumps an object in RDoc::RI to an appropriate format for Dixi,
    # usually either a Hash or String.
    def dump_ri( ri )
      case ri
      when RDoc::RI::ClassDescription
        dump_class_desc( ri )
      when RDoc::RI::ModuleDescription
        dump_module_desc( ri )
      when RDoc::RI::Attribute
        dump_attribute( ri )
      when RDoc::RI::Constant
        dump_constant( ri )
      when RDoc::RI::IncludedModule
        ri.name
      when RDoc::RI::MethodSummary
        ri.name
      when RDoc::RI::MethodDescription
        dump_method_desc( ri )
      else
        raise UnknownRIObject, "Unknown RI object #{ri.inspect}"
      end
    end


    # Dumps a RDoc::RI::ModuleDescription or RDoc::RI::ClassDescription
    # as a Hash for Dixi. Called by dump_class_description and
    # dump_module_description.
    def dump_classmod_desc( cm )
      { "name"      => cm.full_name,
        "constants" => cm.constants.collect{ |c| dump_ri(c) },
        "includes"  => cm.includes.collect{ |i| dump_ri(i) },
        "details"   => dump_markup( cm.comment ),
        "imethods"  => cm.instance_methods.collect{ |meth|
          cm.full_name + "#" + meth.name
        },
        "cmethods"  => cm.class_methods.collect{ |meth|
          cm.full_name + "." + meth.name
        },
      }.tap{ |h|
        h.delete("constants") if h["constants"].empty?
        h.delete("includes" ) if h["includes" ].empty?
        h.delete("details"  ) if h["details"  ].empty?
        h.delete("imethods" ) if h["imethods" ].empty?
        h.delete("cmethods" ) if h["cmethods" ].empty?
      }
    end


    # Dumps a RDoc::RI::ClassDescription as a Hash for Dixi.
    def dump_class_desc( klass )
      dump_classmod_desc( klass ).merge({
        "type"       => "class",
        "attributes" => klass.attributes.collect{ |a| dump_ri(a) },
        "base"       => klass.superclass,
      }).tap{ |h|
        h.delete("attributes") if h["attributes"].empty?
        h.delete("base") if h["base"] == "Object"
      }
    end


    # Dumps a RDoc::RI::ModuleDescription as a Hash for Dixi.
    def dump_module_desc( mod )
      dump_classmod_desc( mod ).merge({
        "type" => "module",
      })
    end


    # Dumps a RDoc::RI::Constant as a Hash for Dixi.
    def dump_constant( const )
      { "name"  => const.name,
        "value" => const.value,
        "info"  => dump_markup( const.comment ),
      }.tap{ |h|
        h.delete("value") if h["value"].empty?
        h.delete("info" ) if h["info" ].empty?
      }
    end


    # Dumps a RDoc::RI::Attribute as a Hash for Dixi.
    def dump_attribute( attr )
      { "name"  => attr.name,
        "read"  => (attr.rw =~ /R/ ? true : false),
        "write" => (attr.rw =~ /W/ ? true : false),
        "info"  => dump_markup(attr.comment),
      }.tap{ |h|
        h.delete("read" ) unless h["read" ]
        h.delete("write") unless h["write"]
        h.delete("info" ) if h["info"].empty?
      }
    end


    # Dumps a RDoc::RI::MethodDescription as a Hash for Dixi.
    def dump_method_desc( meth )
      # name of the class or module holding this method
      classmod = meth.full_name.split(/[#.]/)[0]

      { "name"       => meth.full_name,
        "type"       => (meth.is_singleton ? "class" : "instance")+" method",
        "aliases"    => meth.aliases.collect{ |al|
          classmod + (meth.is_singleton ? "#" : ".") + al.name
        },
        "details"    => dump_markup( meth.comment ),
        "args"       => split_method_params( meth.params ),
        "visibility" => meth.visibility,
      }.tap{ |h|
        h.delete("aliases"   ) if h["aliases"].empty?
        h.delete("details"   ) if h["details"].empty?
        h.delete("args"      ) if h["args"   ].empty?
        h.delete("visibility") if h["visibility"] == "public"
      }
    end


    # Try to split the params into an args array, but bail out with []
    # if parsing fails.
    def split_method_params( params )
      # If it has multiple lines, read only the first one.
      params = params.lines.first

      # If it has (), get rid of everything except inside the ()
      if params =~ /\(.*\)/
        begin
          params = params.match(/^[^(]*\((.*)\)\s*$/)[1].strip
        rescue
          # Parsing failed. Oh well, we tried.
          return []
        end
      end

      # Split by comma, perhaps with whitespace before or after
      params.split(/\s*,\s*/).collect{ |param|
        # Split by =, perhaps with whitespace before or after
        parts = param.strip.split(/\s*=\s*/)
        if parts.size > 1
          {"name" => parts[0], "default" => parts[1]}
        else
          {"name" => parts[0]}
        end
      }
    end


    # Takes an instance of a class in RDoc::Markup and converts it
    # to kramdown syntax. It can also take an Array of such, in which
    # case it converts each one and joins them into one string.
    # 
    def dump_markup( markup )
      case markup
      when Array
        markup.collect{ |m| dump_markup(m) }.join("\n")
      when RDoc::Markup::Flow::P
        dump_markup_body(markup.body)+"\n"
      when RDoc::Markup::Flow::VERB
        indent( unescape_entities(markup.body), 2 )
      when RDoc::Markup::Flow::RULE
        "-----"
      when RDoc::Markup::Flow::LIST
        markup.contents.collect{|item|
          case item
          when RDoc::Markup::Flow::LI
            dump_list_item(item, markup.type)
          else
            dump_markup( item )
          end
        }.join("\n") + "\n"
      when nil
        ""
      else
        raise UnknownMarkup, "Unknown markup #{markup.inspect}"
      end
    end

    # Dumps a RDoc::Markup::Flow::LI to kramdown syntax.
    def dump_list_item( markup, type=:BULLET )
      case type
      when :BULLET
        "* "+dump_markup_body(markup.body)
      when :NOTE
        # definition list
        markup.label+"\n  : "+dump_markup_body(markup.body)
      else
        markup.label+" "+dump_markup_body(markup.body)
      end
    end

    # Dump some RDoc body text, converting some formatting.
    def dump_markup_body( body )
      # Change Rdoc's API link syntax "{Foo::Bar.baz}" to Dixi's
      # syntax "[[Foo::Bar.baz]]".
      body.gsub(/\{((?:[A-Za-z0-9]+(?:\.|#|::)?)+)\}/, "[[\\1]]")
    end


    def unescape_entities( str )
      str.
        gsub("&gt;", ">").
        gsub("&lt;", "<").
        gsub("&amp;", "&")
    end


    def indent( str, level=2 )
      str.lines.collect{ |line| " "*level + line}.join
    end

  end
end



# Run main() if this script is being executed.
if __FILE__ == $0
  main()
end
